#!/usr/bin/python

from __future__ import print_function
import time
import pymysql
from warnings import filterwarnings, resetwarnings
from providers import terminal, server, result
from commons import PyMyToolsArgParser, PyMyToolsConnection, PyMyToolsDelay


# Parser instantiation

arg_parser = PyMyToolsArgParser('Print diagnostic information for a SELECT query')

arg_parser.parser.add_argument('--input-file', help='Input file containing the query', required=True)
arg_parser.parser.add_argument('--trace', help='Show optimizer trace (EXPLAIN JSON)',
                               action='store_true', default=False)
arg_parser.parser.add_argument('--vertical', help='Use vertical output instead of tabular for EXPLAIN',
                               action='store_true', default=False)
arg_parser.parser.add_argument('--profile', help='Execute the query twice with profiling',
                               action='store_true', default=False)

arg_parser.parse_args()
arg_parser.handle_version()
arg_parser.handle_connection_parameters()

report_file = arg_parser.args['input_file']
report_trace = arg_parser.args['trace']
report_profile = arg_parser.args['profile']
report_vertical = arg_parser.args['vertical']
report_partitions = arg_parser.args['partitions']

try:

    report_file_handle = open(report_file, 'r')
    report_query = report_file_handle.read().split()
    report_file_handle.close()

    # remove SELECT

    if report_query[0].lower() != 'select':

        raise Exception('Statement text must begin with SELECT')

    del report_query[0]

    # remove SQL_NO_CACHE, if any

    if report_query[0].lower() == 'sql_no_cache':

        del report_query[0]

    report_query.insert(0, 'select sql_no_cache')
    report_query = ' '.join(report_query)

except IOError as e:

    raise Exception('Could not open input file: %s' % e)

# Delay execution if necessary, connect to database

delay = PyMyToolsDelay(arg_parser)
delay.delay()

dbc = PyMyToolsConnection(arg_parser)
dbc.connect()

# Header

header_lines = [
    'pmt_query_report invoked at %s UTC; input = %s, trace = %s, profile = %s'
    % (time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime()), report_file, report_trace, report_profile)
]

print(terminal.get_header_l1(header_lines, 120))

# EXPLAIN

filterwarnings('ignore', category=pymysql.Warning)

print(terminal.get_header_l2(['EXPLAIN output']))

explain_query = 'explain partitions %s' % report_query if report_partitions else 'explain partitions %s' % report_query

explain_result = server.execute_raw_dict(dbc.connection, explain_query)

print(result.result_format_vertical(explain_result) if report_vertical
      else result.result_format_tabular(explain_result))

# EXPLAIN FORMAT=JSON

if report_trace:

    print(terminal.get_header_l2(['Optimizer trace']))

    explain_query = 'explain format=json %s' % report_query

    explain_result = server.execute_raw_dict(dbc.connection, explain_query)

    print(result.result_format_vertical(explain_result))

# RUN + PROFILE

if report_profile:

    print(terminal.get_header_l2(['Query profile for 2 consecutive executions']))

    server.execute_raw_dict(dbc.connection, 'set profiling = 1')

    # it's 2 and 4 because statements 1 and 3 are SHOW WARNINGS generated by the driver after SET PROFILING = 1 and
    # SHOW PROFILE
    server.execute_raw_dict(dbc.connection, report_query)
    print(result.result_format_tabular(server.execute_raw_dict(dbc.connection, 'show profile for query 2')))

    server.execute_raw_dict(dbc.connection, report_query)
    print(result.result_format_tabular(server.execute_raw_dict(dbc.connection, 'show profile for query 4')))

resetwarnings()

# Print original query

print(terminal.get_header_l2(['Tested query']))

print(report_query)
print('')

# Cleanup

print('>>> Script execution finished at %s UTC' % time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime()))
